#!/usr/bin/python3

import time
import logging
import sys
import select

from optparse import OptionParser
from logging import warning as warn, log, debug, info, error, critical


###########################################################################
# This returns true if all 4 players are in joined state, false otherwise
#
def allJoined():
    # default to true
    state = True

    # if any player has not joined, set to false
    for player in players:
        if 'state' not in player.state or player.state['state'] != 2:
            state = False

    return state


###########################################################################
# This sends a start message to begin the game: it figures out who the
# creator is and sends a message as that person
#
def sendStart():
    # figure out the creator
    for player in players:
        if player.state['creator'] == 1:
            player.sendStart()
            return


###########################################################################
# parse our options

parser = OptionParser()

# add an option to reduce the chatty-ness of the logs: this doesn't do very
# much as yet
parser.add_option("-q", "--quiet",
                  dest="quiet",
                  default=False,
                  action="store_true",
                  help="don't print anything to stdout")

# add an option to set the team 0 class name: if we don't have a class name,
# we default to the random player
parser.add_option("-0", "--team0",
                  dest="team0",
                  default='randomplayer',
                  help="set the class name for Team 0 players")

# add an option to set the team 1 class name: if we don't have a class name,
# we default to the random player
parser.add_option("-1", "--team1",
                  dest="team1",
                  default='randomplayer',
                  help="set the class name for Team 1 players")

(options, args) = parser.parse_args()


###########################################################################
# set up logging

# we have two types of formatters: one for the file (with more detailed
# timing and message levels) and a more compact one for stdout
fhfmt = logging.Formatter(
    fmt="%(asctime)s.%(msecs)03d :: %(levelname)s :: %(message)s",
    datefmt='%Y-%m-%d %H:%M:%S')
chfmt = logging.Formatter(
    fmt="%(asctime)s :: %(message)s",
    datefmt='%Y-%m-%d %H:%M:%S')

# get the root logger
logger = logging.getLogger('')
logger.setLevel(logging.DEBUG)

# make a console handler and add it, if quiet isn't enabled
if not options.quiet:
    ch = logging.StreamHandler(sys.stdout)
    ch.setFormatter(chfmt)
    logger.addHandler(ch)

# make the logfile handler and add it
fh = logging.FileHandler("peuchre.log",mode="a+")
fh.setFormatter(fhfmt)
logger.addHandler(fh)


###########################################################################
# some other initialization

# we track whether we've sent a start message or not
started = 0

# this will be the list of active sockets to run select on
inputs = []
players = []

###########################################################################
# mainline

info("This is peuchre")

# take
Team0 = __import__(options.team0, globals(), locals(), ['Player'], 0).Player
Team1 = __import__(options.team1, globals(), locals(), ['Player'], 0).Player

# ok, I know Python is supposed to be EFAP, but I think it's a better idea
# to check that the player classes are providing the necessary methods
# before, since we can handle it more gracefully once
try:
    callable(Team0.decideOrderPass)
    callable(Team0.decideDrop)
    callable(Team0.decideDefend)
    callable(Team0.decidePlayLead)
    callable(Team0.decidePlayFollow)
except AttributeError:
    info("")
    error("Hmm, the Team0 class ('%s') isn't providing all"
        % (options.team0))
    error("the necessary methods:")
    for method in ("decideOrderPass()","decideDrop()","decideDefend()",
        "decidePlayLead()","decidePlayFollow()"):
        info(method)

try:
    callable(Team1.decideOrderPass)
    callable(Team1.decideDrop)
    callable(Team1.decideDefend)
    callable(Team1.decidePlayLead)
    callable(Team1.decidePlayFollow)
except AttributeError:
    info("")
    error("Hmm, the Team1 class ('%s') isn't providing all"
        % (options.team1))
    error("the necessary methods:")
    for method in ("decideOrderPass()","decideDrop()","decideDefend()",
        "decidePlayLead()","decidePlayFollow()"):
        info(method)


# now we create up to 4 players and join them to the server: we stagger the
# player joins by team, since the server will assign the added players to team
# 0, then team 1, then team 0 again, then team 1 again; after each join, we
# check if the join succeeded, and if so, we add the player to the list of
# players and sockets
player = Team0(server="127.0.0.1", port=1234, name="p0")
if player.sendJoin():
    players.append(player)
    inputs.append(player.s)
player = Team1(server="127.0.0.1", port=1234, name="p1")
if player.sendJoin():
    players.append(player)
    inputs.append(player.s)
player = Team0(server="127.0.0.1", port=1234, name="p2")
if player.sendJoin():
    players.append(player)
    inputs.append(player.s)
player = Team1(server="127.0.0.1", port=1234, name="p3")
if player.sendJoin():
    players.append(player)
    inputs.append(player.s)

# loop across our player sockets checking for input to process
while inputs:
    readable, writable, exceptional = select.select(inputs, [], inputs)

    # loop across each readable socket
    for player in players:
        if player.s in readable:
            player.parseMessage()

    # each time through, we drive game state forward by checking to see
    # the current hand state
    #  - if pregame (0), and all players joined, send start
    #  - if hole (1), then someone has an option to order the hole card
    #  - if trump (2), then someone has an option to call trump
    #  - if defend (3), then someone has an option to defend alone
    #  - if play (4), then someone has an option to play
    # 
    # the game state is sent to all players, but it should be the same
    # for them all, so we check it against player 0, but it would work
    # to check it against any other player too
    if allJoined():
        # this sends the start message: let the games begin!
        if players[0].state['hstate'] == 0 and started != 1:
            info("")
            info("game: everyone is joined, sending start %d" % (started))
            sendStart()
            started = 1
