#!/usr/bin/python3

import time
import logging
import sys
import select

from optparse import OptionParser
from logging import warning as warn, log, debug, info, error, critical

from record import Record


###########################################################################
# This returns true if all 4 players are in joined state, false otherwise
#
def allJoined(players):
    # default to true
    state = True

    # if any player has not joined, set to false
    for player in players:
        if 'state' not in player.state or player.state['state'] != 2:
            state = False

    return state


###########################################################################
# This sends a start message to begin the game: it figures out who the
# creator is and sends a message as that person
#
def sendStart(players):
    # figure out the creator
    for player in players:
        if player.state['creator'] == 1:
            player.sendStart()
            return


###########################################################################
# This routine plays a game:
#  - it instantiates 4 players and connects them to the server
#  - it serves messages from the server to the players until a
#    parseMessage() call returns false
#  - then it exits
#
def playGame(server, port, **kwargs):
    # print our current stats
    if options.stats: r.print()

    # if we were passed a game count, set it
    if 'gcount' in kwargs: gcount = kwargs['gcount']

    # we use this to track active sockets and players
    inputs = []
    players = []

    # we track whether we've sent a start message or not
    started = 0

    # first we create up to 4 players and join them to the server: we
    # stagger the player joins by team, since the server will assign the
    # added players to team 0, then team 1, then team 0 again, then team
    # 1 again; after each join, we check if the join succeeded, and if so,
    # we add the player to the list of players and sockets
    player = Team1(server=server,port=port,name="p0t1",record=r,gcount=gcount)
    if player.sendJoin():
        players.append(player)
        inputs.append(player.s)
    player = Team2(server=server,port=port,name="p1t2",record=r,gcount=gcount)
    if player.sendJoin():
        players.append(player)
        inputs.append(player.s)
    player = Team1(server=server,port=port,name="p2t1",record=r,gcount=gcount)
    if player.sendJoin():
        players.append(player)
        inputs.append(player.s)
    player = Team2(server=server,port=port,name="p3t2",record=r,gcount=gcount)
    if player.sendJoin():
        players.append(player)
        inputs.append(player.s)

    # loop across our player sockets checking for input to process
    while players:
        readable, writable, exceptional = \
            select.select(inputs, [], [], options.timeout)

        # if there are no results in inputs, then we hit the timeout, which
        # probably means something went wrong (a client died?) and we should
        # just reset the whole thing
        if len(readable) == 0:
            error("uh-oh, hit timeout, terminating game")
            return

        # loop across each readable socket
        for player in players:
            if player.s in readable:
                if not player.parseMessage():
                    players.remove(player)
                    inputs.remove(player.s)

        # Ugh, the server doesn't support a STARTOFFER message (yet), so
        # we need to detect when we have 4 connected players to know when
        # to start
        if players and allJoined(players):
            # this sends the start message: let the games begin!
            if players[0].state['hstate'] == 0 and started != 1:
                info("")
                info("game: everyone is joined, sending start %d" % (started))
                sendStart(players)
                started = 1

    # if we get here, all the clients have left, so we just return and a
    # new game will be triggered
    return


###########################################################################
# parse our options

parser = OptionParser()

# add an option to specify the euchred server
parser.add_option("-s", "--server",
                  dest="server",
                  default="127.0.0.1",
                  action="store",
                  help="name of the euchred server to contact")

# add an option to specify the euchred port
parser.add_option("-p", "--port",
                  type="int",
                  dest="port",
                  default=1234,
                  action="store",
                  help="port of the euchred server to contact")

# add an option to reduce the chatty-ness of the logs: this doesn't do very
# much as yet
parser.add_option("-q", "--quiet",
                  dest="quiet",
                  default=False,
                  action="store_true",
                  help="don't print anything to stdout")

# add an option to enable stats output: this shows a live view of the data
# being gathered; this automatically implies -q
parser.add_option("--stats",
                  dest="stats",
                  default=False,
                  action="store_true",
                  help="show live stats, implies --quiet")

# add an option to override the timeout logic: by default the server will
# terminate if there is more than 30s of idle from the server, but this
# can interfere with manual client play
parser.add_option("--notimeout",
                  dest="timeout",
                  default=30,
                  const=999999,
                  action="store_const",
                  help="disable server timeout, allows for manual clients")

# add an option to set the team 0 class name: if we don't have a class name,
# we default to the random player
parser.add_option("-1", "--team1",
                  dest="team1",
                  default='randomplayer',
                  help="set the class name for Team 0 players")

# add an option to set the team 1 class name: if we don't have a class name,
# we default to the random player
parser.add_option("-2", "--team2",
                  dest="team2",
                  default='randomplayer',
                  help="set the class name for Team 1 players")

# add an option to set the number of games to play, default to a large value
parser.add_option("-n", "--numgames",
                  type="int",
                  dest="numgames",
                  default=999999999,
                  help="set the number of games to loop for")

(options, args) = parser.parse_args()


###########################################################################
# set up logging

# we have two types of formatters: one for the file (with more detailed
# timing and message levels) and a more compact one for stdout
fhfmt = logging.Formatter(
    fmt="%(asctime)s.%(msecs)03d :: %(message)s",
    datefmt='%Y-%m-%d %H:%M:%S')
chfmt = logging.Formatter(
    fmt="%(asctime)s :: %(message)s",
    datefmt='%Y-%m-%d %H:%M:%S')

# get the root logger
logger = logging.getLogger('')
logger.setLevel(logging.INFO)

# make a console handler and add it, if neither quiet nor stats are enabled
if not options.quiet and not options.stats:
    ch = logging.StreamHandler(sys.stdout)
    ch.setFormatter(chfmt)
    logger.addHandler(ch)

# make the logfile handler and add it
fh = logging.FileHandler("peuchre.log",mode="a+")
fh.setFormatter(fhfmt)
logger.addHandler(fh)


###########################################################################
# mainline

info("This is peuchre")

# create a Record object: we'll pass this to the clients, and they'll use
# it to record data about their hands: we provide the name of the team
# algorithms so Record can include it in the status output
r = Record(team1=options.team1,team2=options.team2)

# take
Team1 = __import__(options.team1, globals(), locals(), ['Player'], 0).Player
Team2 = __import__(options.team2, globals(), locals(), ['Player'], 0).Player

# ok, I know Python is supposed to be EFAP, but I think it's a better idea
# to check that the player classes are providing the necessary methods
# before, since we can handle it more gracefully once
try:
    callable(Team1.decideOrderPass)
    callable(Team1.decideDrop)
    callable(Team1.decideDefend)
    callable(Team1.decidePlayLead)
    callable(Team1.decidePlayFollow)
except AttributeError:
    info("")
    error("Hmm, the Team1 class ('%s') isn't providing all"
        % (options.team1))
    error("the necessary methods:")
    for method in ("decideOrderPass()","decideDrop()","decideDefend()",
        "decidePlayLead()","decidePlayFollow()"):
        info(method)

try:
    callable(Team2.decideOrderPass)
    callable(Team2.decideDrop)
    callable(Team2.decideDefend)
    callable(Team2.decidePlayLead)
    callable(Team2.decidePlayFollow)
except AttributeError:
    info("")
    error("Hmm, the Team2 class ('%s') isn't providing all"
        % (options.team2))
    error("the necessary methods:")
    for method in ("decideOrderPass()","decideDrop()","decideDefend()",
        "decidePlayLead()","decidePlayFollow()"):
        info(method)

# we use this to keep count of the number of games we've done
count = 0
try:
    while count < options.numgames:
        playGame(options.server,options.port,gcount=count)
        count += 1
except KeyboardInterrupt:
    # means we've been interrupted with ^C: handle it and fall through
    # to the final write methods
    print("interrupted")

# do a final print() (just for pretty-ness) and a final forced write
r.print(clear=False)
r.writeForce()
